code_member {
    enum CodeMemberType type;
    union {
        import* import;
        function* function;
        class* class;
    } content;
}

code {
    list(code_member) members;
};

import {
    string(identifier) name;
    string source;
};

function {
    string(identifier) name;
    string(type) return_type;
    list(variable) parameters;
    list(statement) body;
};

class_member {
    enum ClassMemberType type;
    union {
        function* method;
        variable* attribute;
    } content;
};

class {
    string(identifier) name;
    list(class_member) members;
};

variable {
    string(type) var_type;
    string(identifier) name;
    expression* value;
};

statement {
    enum StatementType type;
    union {
        expression* expr;
        variable* var_decl;
        if* if_stmt;
        while* while_stmt;
        for* for_stmt;
        expression* return_stmt;
    } stmt;
};

expression {
    enum operatorType operator;
    expression* left;
    expression* right;
};

if {
    expression* condition;
    list(statement) body;
    list(if) elif;
    list(statement) else_body;
};

while {
    expression* condition;
    list(statement) body;
};

for {
    variable* init;
    expression* condition;
    expression* increment;
    list(statement) body;
};

primary {
    enum PrimaryType type;
    union {
        string int_value;
        string float_value;
        string string_value;
        string bool_value;
        expression* expr;
        primary* not_operand;
        primary* neg_operand;
        variable_access* var_access;
    } value;
};

variable_access {
    enum AccessType access_type;  // name, func_call, get_attr, get_seq
    union {
        string(identifier) name;
        variable_access* var;
    } base;
    union {
        list(expression) func_call;
        string(identifier) get_attr;
        expression* get_seq;
    } access;
};

node<T> {
    T* content;
    node<T>* next;
};

list<T> {
    node<T>* head;
    node<T>* tail;
};
