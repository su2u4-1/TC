code_member {
    enum CodeMemberType type;
    union {
        import* import;
        function* function;
        class* class;
    } content;
}

code {
    list<code_member> members;
    scope* global_scope;
};

import {
    string(identifier) name;
    string source;
};

function {
    string(identifier) name;
    string(type) return_type;
    list<variable> parameters;
    list<statement> body;
    scope* function_scope;
};

method {
    string(identifier) name;
    string(type) return_type;
    list<variable> parameters;
    list<statement> body;
    scope* method_scope;
};

class_member {
    enum ClassMemberType type;
    union {
        method* method;
        variable* attribute;
    } content;
};

class {
    string(identifier) name;
    list<class_member> members;
    scope* class_scope;
};

variable {
    string(type) var_type;
    string(identifier) name;
    expression* value;
};

statement {
    enum StatementType type;
    union {
        expression* expr;
        variable* var_decl;
        if* if_stmt;
        while* while_stmt;
        for* for_stmt;
        expression* return_stmt;
    } stmt;
};

if {
    expression* condition;
    list<statement> body;
    list<else_if> else_if;
    list<statement> else_body;
};

else_if {
    expression* condition;
    list<statement> body;
};

for {
    variable* initializer;
    expression* condition;
    expression* increment;
    list<statement> body;
};

while {
    expression* condition;
    list<statement> body;
};

expression {
    enum operatorType operator;
    (expression* | primary*) left;
    expression* right;
};

primary {
    enum PrimaryType type;
    union {
        string literal_value;   // int, float, string, true, false
        expression* expr;       // expr
        primary* operand;       // not, neg
        variable_access* var;   // variable access
    } value;
};

variable_access {
    enum AccessType access_type;  // name, func_call, get_attr, get_seq
    union {
        string(identifier) name;
        variable_access* var;
    } base;
    union {
        list<expression> func_call;
        string(identifier) get_attr;
        expression* get_seq;
    } access;
};

scope {
    scope* parent;
    map<string, pair<string(type), int>> variables;
}

node<T> {
    T* content;
    node<T>* next;
};

list<T> {
    node<T>* head;
    node<T>* tail;
};
